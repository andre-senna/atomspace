#include "PatternIndexImplementationRAM.h"
#include "../CartesianProductGenerator.h"
#include <stdexcept>

using namespace opencog;
using namespace std;

PatternIndexImplementationRAM::PatternIndexImplementationRAM()
{
    nextKBBID = 1;
    disableAutoGeneratedPatterns = false;
}

PatternIndexImplementationRAM::~PatternIndexImplementationRAM() 
{
}

// --------------------------------------------------------------------------------
// Public PatternIndex API

void PatternIndexImplementationRAM::index(const KnowledgeBuildingBlock &kbb, 
                                          const Handle &toplevel)
{
    if (disableAutoGeneratedPatterns) {
        IndexNode *node = findIndexNode(kbb, &rootLocal, true);
        insertKBBOccurrence(toplevel, node->kbbID);
    } else {
        vector<KnowledgeBuildingBlock *> nodeList;
        buildPatterns(nodeList, kbb, 0);
        for (auto n : nodeList) {
            if (DEBUG) n->printForDebug("Added pattern: ", "\n");
            IndexNode *node = findIndexNode(*n, &rootLocal, true);
            insertKBBOccurrence(toplevel, node->kbbID);
            delete n;
        }
    }
    if (DEBUG) printf("New KBB indexed\n");
}

void PatternIndexImplementationRAM::index(const KnowledgeBuildingBlock &kbb, 
                                          KBB_UUID id)
{
    if (disableAutoGeneratedPatterns) {
        IndexNode *node = findIndexNode(kbb, &rootGlobal, true);
        insertKBBOccurrence(id, node->kbbID);
    } else {
        vector<KnowledgeBuildingBlock *> nodeList;
        buildPatterns(nodeList, kbb, 0);
        for (auto n : nodeList) {
            IndexNode *node = findIndexNode(*n, &rootGlobal, true);
            insertKBBOccurrence(id, node->kbbID);
            delete n;
        }
    }
    if (DEBUG) printf("New KBB indexed\n");

    //IndexNode *node = findIndexNode(kbb, &rootGlobal, true);
    //insertKBBOccurrence(id, node->kbbID);
    //if (DEBUG) printf("New KBB indexed\n");
}

void PatternIndexImplementationRAM::query(list<Handle> &answer, 
                                          const KnowledgeBuildingBlock &key,
                                          bool localOnly)
{
    IndexNode *node = findIndexNode(key, &rootLocal, false);
    if (node == nullptr) return;
    auto it = occurrencesLocal.find(node->kbbID);
    if (it == occurrencesLocal.end()) throw runtime_error("Mapping not found");
    if (DEBUG) printf("Query: leaf has %lu UUIds\n", (*it).second->size());
    answer.insert(answer.begin(), (*it).second->begin(), (*it).second->end());
}

void PatternIndexImplementationRAM::query(list<KBB_UUID> &answer, 
                                          const KnowledgeBuildingBlock &key,
                                          bool externOnly)
{
    IndexNode *node = findIndexNode(key, &rootGlobal, false);
    if (node == nullptr) return;
    auto it = occurrencesGlobal.find(node->kbbID);
    if (it == occurrencesGlobal.end()) throw runtime_error("Mapping not found");
    if (DEBUG) printf("Query: leaf has %lu UUIds\n", (*it).second->size());
    answer.insert(answer.begin(), (*it).second->begin(), (*it).second->end());
}

// --------------------------------------------------------------------------------
// Private methods

void PatternIndexImplementationRAM::insertKBBOccurrence(const Handle &kbbReference,
                                                        const KBB_DBID &kbbID)
{
    auto it = occurrencesLocal.find(kbbID);
    if (it == occurrencesLocal.end()) {
        set<Handle> *newSet = new set<Handle>();
        newSet->insert(kbbReference);
        occurrencesLocal.emplace(kbbID, newSet);
    } else {
        (*it).second->insert(kbbReference);
    }
}

void PatternIndexImplementationRAM::insertKBBOccurrence(KBB_UUID kbbReference,
                                                        const KBB_DBID &kbbID)
{
    auto it = occurrencesGlobal.find(kbbID);
    if (it == occurrencesGlobal.end()) {
        set<KBB_UUID> *newSet = new set<KBB_UUID>();
        newSet->insert(kbbReference);
        occurrencesGlobal.emplace(kbbID, newSet);
    } else {
        (*it).second->insert(kbbReference);
    }
}

PatternIndexImplementationRAM::IndexNode *PatternIndexImplementationRAM::findIndexNode(
                                              const KnowledgeBuildingBlock &kbb,
                                              IndexNode *root,
                                              bool insertFlag)
{
    unsigned short int size = kbb.size();
    if (size == 0) {
        if (insertFlag) {
            throw runtime_error("Attempt to index an empty KBB");
        } else {
            return nullptr;
        }
    }

    // Traverse the prefix index tree to find the leaf corresponding to the
    // passed KBB. If the leaf already exists, add another occurrence to
    // the corresponding KBB ID. Otherwise a new KDD ID is created and the
    // occurrence is added.

    unsigned short int kbbCursor = 0;
    IndexNode *node = root;
    IndexNode::IndexLinkTag tag;

    while (kbbCursor < size) {
        tag.first = kbb.getTypeAt(kbbCursor);
        tag.second = kbb.getArityAt(kbbCursor);
        IndexNode::TagToIndexNodeMap::iterator it = (node->children).find(tag);
        if (it == (node->children).end()) {
            // Mismatch. if inserting, a new IndexNode is created.
            if (insertFlag) {
                IndexNode *newNode = new IndexNode();
                (node->children).emplace(tag, newNode);
                node = newNode;
            } else {
                return nullptr;
            }
        } else {
            // Reuse branch
            node = (*it).second;
        }
        kbbCursor++;
    }

    if (insertFlag) {
        // At this point, node is pointing to the proper leaf, which can be a newly
        // created one. In this case, a new KBB ID need to be assigned to this leaf
        if (node->kbbID == 0) {
            node->kbbID = nextKBBID++;
        }
    }

    return node;
}

void PatternIndexImplementationRAM::buildPatterns(vector<KnowledgeBuildingBlock *> &answer,
                                                  const KnowledgeBuildingBlock &baseKBB,
                                                  unsigned int cursor)
{
    //printf("XXX buildPatterns()\n");
    //baseKBB.printForDebug("XXX baseKBB: ", "\n");
    //printf("XXX cursor: %u\n", cursor);
    Arity a = baseKBB.getArityAt(cursor);
    Type t = baseKBB.getTypeAt(cursor);
    KBB_HASHCODE h = baseKBB.getAtomIDAt(cursor);
    //printf("XXX %lu %u %lu\n", a, t, h);

    KnowledgeBuildingBlock *pattern;
    CompoundHashValue hash;

    if (a == 0) {
        // Its a Node
        //printf("XXX NODE\n");
        pattern = new KnowledgeBuildingBlock();
        pattern->pushBack(t, 0, h);
        answer.push_back(pattern);
        //pattern->printForDebug("XXX pattern: ", "\n");
    } else if (a > MAX_AUTO_EXPANDABLE_ARITY) {
        // Its a Link but its arity is too large so subpatterns are not computed
        pattern = new KnowledgeBuildingBlock();
        pattern->pushBackAtom(baseKBB, cursor);
        answer.push_back(pattern);
        //pattern->printForDebug("XXX pattern: ", "\n");
    } else {
        // Its a Link whose subpattern will be computed
        //printf("XXX LINK\n");
        // TODO prevent combinatorial explosion
        vector<vector<KnowledgeBuildingBlock *>> linkTargetPatterns;
        vector<KnowledgeBuildingBlock *> linkTargetPatternsSelection;
        unsigned int p = cursor + 1;
        for (unsigned int i = 0; i < a; i++) {
            linkTargetPatterns.emplace(linkTargetPatterns.end());
            buildPatterns(linkTargetPatterns[i], baseKBB, p);
            //printf("XXX RETURN FROM RECURSION\n");
            p += (baseKBB.getArityAt(p) + 1);
        }
        //printf("XXX linkTargetPatterns.size(): %lu\n", linkTargetPatterns.size());
        std::vector<unsigned int> v; // just to build CartesianProductGenerator below
        //unsigned int XXXi = 0;
        for (auto elem : linkTargetPatterns) {
            //printf("XXX linkTargetPatterns[%u].size(): %lu\n", XXXi++, elem.size());
            //for (auto XXXelem : elem) {
                //printf("p: %p\n", XXXelem);
            //}
            v.push_back(elem.size());
        }
        bool unorderedFlag = nameserver().isA(t, UNORDERED_LINK);
        CartesianProductGenerator cp(v, false, false);
        while (! cp.depleted()) {
            //cp.printForDebug(" XXX cp: ", "\n");
            pattern = new KnowledgeBuildingBlock();
            pattern->pushBack(t, a);
            hash.reset();
            hash.feed(t);
            hash.feed(a);
            if (unorderedFlag) {
                //printf("XXX UNORDERED_LINK\n");
                linkTargetPatternsSelection.clear();
                for (unsigned int i = 0; i < a; i++) {
                    linkTargetPatternsSelection.push_back(linkTargetPatterns[i][cp.at(i)]);
                }
                struct {
                    bool operator()(KnowledgeBuildingBlock *a, KnowledgeBuildingBlock *b) const
                    {   
                        return a->definition[0].atomHash < b->definition[0].atomHash;
                    }   
                } customLess;
                std::sort(linkTargetPatternsSelection.begin(), linkTargetPatternsSelection.end(), customLess);
                for (unsigned int i = 0; i < a; i++) {
                    KnowledgeBuildingBlock *subPattern = linkTargetPatternsSelection[i];
                    pattern->pushBack(subPattern);
                    hash.feed(subPattern->definition[0].atomHash);
                }
            } else {
                //printf("XXX ORDERED_LINK\n");
                for (unsigned int i = 0; i < a; i++) {
                    KnowledgeBuildingBlock *subPattern = linkTargetPatterns[i][cp.at(i)];
                    pattern->pushBack(subPattern);
                    hash.feed(subPattern->definition[0].atomHash);
                }
            }
            pattern->definition[0].atomHash = hash.get();
            answer.push_back(pattern);
            //pattern->printForDebug("XXX pattern: ", "\n");
            cp.next();
        }
        for (auto elem1 : linkTargetPatterns) {
            for (auto elem2 : elem1) {
                delete elem2;
                //printf("XXX delete %p\n", elem2);
            }
        }
    }
      
    // Insert "anything of the same type" wildcard (AtomType *)
    pattern = new KnowledgeBuildingBlock();
    hash.reset();
    hash.feed(t | KnowledgeBuildingBlock::TYPED_KBB_PATTERN_MASK);
    pattern->pushBack(t | KnowledgeBuildingBlock::TYPED_KBB_PATTERN_MASK, 0, hash.get());
    answer.push_back(pattern);
    //pattern->printForDebug("XXX pattern: ", "\n");

    // Insert "anything" wildcard: (*)
    pattern = new KnowledgeBuildingBlock();
    hash.reset();
    hash.feed(KnowledgeBuildingBlock::ANY_KBB_PATTERN_MASK);
    pattern->pushBack(KnowledgeBuildingBlock::ANY_KBB_PATTERN_MASK, 0, hash.get());
    answer.push_back(pattern);
    //pattern->printForDebug("XXX pattern: ", "\n");

}

// --------------------------------------------------------------------------------
// IndexNode (inner class) methods

PatternIndexImplementationRAM::IndexNode::IndexNode()
{
    // 0 means NO ID assigned yet
    kbbID = 0;
}

PatternIndexImplementationRAM::IndexNode::~IndexNode()
{
    for (const auto& element : children) {
        delete element.second;
    }
}
